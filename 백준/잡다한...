백트레킹 공식

void dfs(int depth) {
    
    // 1. [종료 조건] : 목표(M개) 달성?
    if (depth == m) {
        // 정답 출력하고
        return; 
    }

    // 2. [탐색 반복] : 후보들을 하나씩
    for (int i = 1; i <= n; i++) {
        
        // 3. [가지치기 & 선택] : 조건 맞으면 고고!
        if (방문 안 했으면 / 조건 맞으면) {
            
            check[i] = 1;   // 1) 체크! (나 이거 쓴다)
            arr[depth] = i; // 2) 기록! (장바구니에 담기)
            
            dfs(depth + 1); // 3) 다음 거 찾으러 다녀와! (재귀)
            
            check[i] = 0;   // 4) 원상복구! (나 이제 안 쓸래, 지워줘) ★제일 중요★
        }
    }
}
///////////////////////////////////////////////////////////
1. 정적 메모리 할당(static memory allocation) ex) int arr[1000001]
- 컴파일 타임 결정 : 프로그램 실행전, 코드를 기계어로 바꾸는 시점에 필요한 메모리 크기 계산(컴파일 과정 중)
- 데이터 세그먼트 활용: 이렇게 선언한 배열은 프로그램의 시작과 동시에 메모리에 자리를 잡고, 종료될때까지 그 위치 그대로 존재.

2. undfined behavior ex) int n; int arr[n];
- 쓰레기값 (garbage value): 초기화되지 않은 지역변수n은 메모리에 남아있던 이전 데이터의 쓰레기값을 그대로 가지고 있음
- 런타임 에러: 이런 쓰레기값이 음수거나 엄청나게 큰 값일 경우, 프로그램 규칙위반(스택 오버플로, 세그멘테이션 폴트, 정수 오버플로 등)으로 간주되어
프로그램 즉시 강제 종료.

3. 가변길이 배열 (variable length array, VLA) ex) scanf("%d", &n); int arr[n];
//c에서만 지원. c++은 지원하지 않음 but gcc/clang 같은 컴파일러들이 알잘딱 변환해줘서 쓸수 있음(vector를 쓰는게 더 안전)
- 런타임 결정: 프로그램 실행 중 입력받은 값에 맞춰 메모리를 잡음(스택)
- 스택 프레임 할당: 스택이라는 메모리 공간에 잠시 머뭄
- 위험 요소: 스택은 공간이 좁아 터질 가능성이 있음(스택 오버플로) -> 별로 권장하지는 않음

4. 동적 메모리 할당
- 힙 세그먼트: 스택보다 훨씬 넓은 힙 메모리 영역 (malloc, free)
- 메모리 누구: 빌려온 메모리를 반납하지 않으면 메모리가 계속 줄어드는 현상 발생. 주의 필요.
